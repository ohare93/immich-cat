<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Main</title>
    <script src="../dist/main.js"></script>
    <script src="../node_modules/thumbhash/thumbhash.js"></script>
    <style>
      .center {
        text-align: center;
        width: auto;
        max-height: 100vh;
        max-width: 100%;
        white-space: nowrap;
      }

      .center img {
        max-width: 100%;
        max-height: 100%;
        display: block;
        margin: 0 auto;
      }

      /* Mobile responsive improvements */
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }

      /* Touch-friendly improvements */
      @media (max-width: 768px) {
        .center img {
          max-height: calc(100vh - 100px); /* Account for mobile browser bars */
        }
      }

      /* Grid responsiveness */
      @media (max-width: 480px) {
        .center {
          white-space: normal;
        }
      }
    </style>
  </head>
  <body>
    <div id="myapp"></div>
    <script type="text/javascript">
      const assetCache = new Map();
      const preloadQueue = new Set();
      const maxCacheSize = 50;

      function fetchWithAuthentication(url, authToken) {
        const headers = new Headers();
        headers.set("x-api-key", authToken);
        return fetch(url, { headers });
      }

      function cleanupOldCache() {
        if (assetCache.size > maxCacheSize) {
          const oldEntries = Array.from(assetCache.entries()).slice(
            0,
            assetCache.size - maxCacheSize,
          );
          oldEntries.forEach(([url, blobUrl]) => {
            URL.revokeObjectURL(blobUrl);
            assetCache.delete(url);
          });
        }
      }

      async function getProtectedAssetUrl(imageUrl, authToken) {
        // Check cache first
        if (assetCache.has(imageUrl)) {
          return assetCache.get(imageUrl);
        }

        if (preloadQueue.has(imageUrl)) {
          while (preloadQueue.has(imageUrl) && !assetCache.has(imageUrl)) {
            await new Promise((resolve) => setTimeout(resolve, 50));
          }
          return assetCache.get(imageUrl);
        }

        preloadQueue.add(imageUrl);

        try {
          // Fetch the image.
          const response = await fetchWithAuthentication(imageUrl, authToken);

          // Create an object URL from the data.
          const blob = await response.blob();
          const objectUrl = URL.createObjectURL(blob);

          // Store in cache
          assetCache.set(imageUrl, objectUrl);
          cleanupOldCache();

          return objectUrl;
        } finally {
          preloadQueue.delete(imageUrl);
        }
      }

      function preloadAsset(imageUrl, authToken) {
        if (!assetCache.has(imageUrl) && !preloadQueue.has(imageUrl)) {
          getProtectedAssetUrl(imageUrl, authToken).catch(() => {});
        }
      }

      class MediaElementBase extends HTMLElement {
        constructor(config) {
          super();
          this.config = config;
          this.assetBlob = null;
          this.currentVideo = null;
        }

        connectedCallback() {
          this.assetUrl = this.getAttribute("asset-url");
          this.apiKey = this.getAttribute("api-key");
          this.preloadList = this.getAttribute("preload-urls");

          this.render();
        }

        async attributeChangedCallback(name, oldValue, newValue) {
          if (name === "api-key") {
            this.apiKey = newValue;
          } else if (name === "asset-url") {
            this.assetUrl = newValue;
            this.assetBlob = null;
            this.cleanupCurrentVideo();
          } else if (name === "preload-urls") {
            this.preloadList = newValue;
          }

          if (
            this.assetUrl &&
            this.apiKey &&
            this.apiKey !== "undefined" &&
            !this.assetBlob
          ) {
            this.render(); // Show loading state

            try {
              this.assetBlob = await getProtectedAssetUrl(
                this.assetUrl,
                this.apiKey,
              );

              if (this.preloadList) {
                const urls = this.preloadList.split(",");
                const urlsToPreload = this.config.preloadCount
                  ? urls.slice(0, this.config.preloadCount)
                  : urls;

                urlsToPreload.forEach((url) => {
                  if (url.trim()) {
                    if (this.config.preloadDelay) {
                      setTimeout(
                        () => preloadAsset(url.trim(), this.apiKey),
                        this.config.preloadDelay,
                      );
                    } else {
                      preloadAsset(url.trim(), this.apiKey);
                    }
                  }
                });
              }

              this.render(); // Show actual asset

              if (this.config.postRender) {
                this.config.postRender(this);
              }
            } catch (error) {
              this.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #f66;">
                  Error loading ${this.config.mediaType}
                </div>
              `;
            }
          }
        }

        static get observedAttributes() {
          return ["asset-url", "api-key", "preload-urls"];
        }

        render() {
          if (this.assetBlob) {
            this.innerHTML = this.config.renderElement(this.assetBlob);
          } else {
            this.innerHTML = this.config.renderLoading();
          }
        }

        cleanupCurrentVideo() {
          if (this.currentVideo) {
            this.currentVideo.pause();
            this.currentVideo.currentTime = 0;
            this.currentVideo.src = "";
            this.currentVideo.load(); // Reset the video element
            this.currentVideo = null;
          }
        }

        disconnectedCallback() {
          this.cleanupCurrentVideo();
        }

        showVideoError(message) {
          this.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; background: #ffebee; border: 2px solid #f44336; border-radius: 8px; padding: 20px; margin: 10px;">
              <div style="color: #d32f2f; font-size: 18px; margin-bottom: 10px;">⚠️ Video Error</div>
              <div style="color: #666; text-align: center; font-size: 14px; max-width: 400px;">${message}</div>
              <div style="color: #999; text-align: center; font-size: 12px; margin-top: 10px;">
                This video may have compatibility issues with this platform.
              </div>
            </div>
          `;
        }

        showVideoWarning(message) {
          const warningDiv = document.createElement('div');
          warningDiv.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 152, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          `;
          warningDiv.textContent = `⚠️ ${message}`;
          
          if (this.style.position !== 'relative') {
            this.style.position = 'relative';
          }
          
          this.appendChild(warningDiv);
          
          setTimeout(() => {
            if (warningDiv.parentNode) {
              warningDiv.remove();
            }
          }, 8000);
        }
      }

      customElements.define(
        "image-from-api",
        class extends MediaElementBase {
          constructor() {
            super({
              mediaType: "image",
              preloadCount: null, // Preload all
              preloadDelay: null, // Immediate
              renderElement: (blobUrl) =>
                `<img src="${blobUrl}" alt="Asset" />`,
              renderLoading: () => `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                  Loading...
                </div>
              `,
              postRender: null,
            });
          }
        },
      );

      customElements.define(
        "video-from-api",
        class extends MediaElementBase {
          constructor() {
            super({
              mediaType: "video",
              preloadCount: 2, // Only preload 2 adjacent videos
              preloadDelay: 1000, // Delay video preloading by 1 second
              renderElement: (blobUrl) =>
                `<video src="${blobUrl}" controls="controls" autoplay loop style="max-width: 100%; max-height: 100%;" />`,
              renderLoading: () => `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                  Loading video...
                </div>
              `,
              postRender: (element) => {
                element.cleanupCurrentVideo();
                
                const video = element.querySelector("video");
                if (video) {
                  element.currentVideo = video;
                  
                  video.addEventListener('loadeddata', () => {
                    if (video.paused) {
                      video.play().catch(() => {});
                    }
                  });
                  
                }
              },
            });
          }
        },
      );

      customElements.define(
        "thumbhash-image",
        class extends HTMLElement {
          constructor() {
            super();
            this.thumbhashString = null;
            this.assetUrl = null;
            this.apiKey = null;
            this.canvas = null;
            this.img = null;
            this.hasLoadedFullImage = false;
          }

          connectedCallback() {
            this.style.display = "block";
            this.style.width = "100%";
            this.style.height = "100%";
            this.style.position = "relative";
            this.style.overflow = "hidden";
            
            this.thumbhashString = this.getAttribute("thumbhash");
            this.assetUrl = this.getAttribute("asset-url");
            this.apiKey = this.getAttribute("api-key");
            
            this.render();
          }

          attributeChangedCallback(name, oldValue, newValue) {
            if (name === "thumbhash") {
              this.thumbhashString = newValue;
            } else if (name === "asset-url") {
              this.assetUrl = newValue;
              this.hasLoadedFullImage = false;
            } else if (name === "api-key") {
              this.apiKey = newValue;
            }
            
            if (this.isConnected) {
              this.render();
            }
          }

          static get observedAttributes() {
            return ["thumbhash", "asset-url", "api-key"];
          }

          async render() {
            this.innerHTML = "";
            
            if (this.thumbhashString && window.thumbhash) {
              this.renderThumbhash();
            }
            
            if (this.assetUrl && this.apiKey && !this.hasLoadedFullImage) {
              this.loadFullImage();
            }
          }

          renderThumbhash() {
            try {
              const binaryString = atob(this.thumbhashString);
              const thumbhashArray = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                thumbhashArray[i] = binaryString.charCodeAt(i);
              }
              
              this.canvas = document.createElement("canvas");
              this.canvas.style.width = "100%";
              this.canvas.style.height = "100%";
              this.canvas.style.objectFit = "cover";
              this.canvas.style.position = "absolute";
              this.canvas.style.top = "0";
              this.canvas.style.left = "0";
              this.canvas.style.filter = "blur(1px)"; // Slight blur for aesthetic
              
              const { w, h, rgba } = window.thumbhash.thumbHashToRGBA(thumbhashArray);
              this.canvas.width = w;
              this.canvas.height = h;
              
              const ctx = this.canvas.getContext("2d");
              const imageData = ctx.createImageData(w, h);
              imageData.data.set(rgba);
              ctx.putImageData(imageData, 0, 0);
              
              this.appendChild(this.canvas);
              
            } catch (error) {
              this.renderPlaceholder();
            }
          }

          renderPlaceholder() {
            const placeholder = document.createElement("div");
            placeholder.style.width = "100%";
            placeholder.style.height = "100%";
            placeholder.style.background = "#f0f0f0";
            placeholder.style.display = "flex";
            placeholder.style.alignItems = "center";
            placeholder.style.justifyContent = "center";
            placeholder.style.color = "#999";
            placeholder.style.fontSize = "12px";
            placeholder.textContent = "Loading...";
            this.appendChild(placeholder);
          }

          async loadFullImage() {
            if (!this.assetUrl || !this.apiKey) return;
            
            try {
              const objectUrl = await getProtectedAssetUrl(this.assetUrl, this.apiKey);
              
              this.img = document.createElement("img");
              this.img.style.width = "100%";
              this.img.style.height = "100%";
              this.img.style.objectFit = "cover";
              this.img.style.position = "absolute";
              this.img.style.top = "0";
              this.img.style.left = "0";
              this.img.style.opacity = "0";
              this.img.style.transition = "opacity 0.3s ease";
              
              this.img.onload = () => {
                this.img.style.opacity = "1";
                this.hasLoadedFullImage = true;
                
                setTimeout(() => {
                  if (this.canvas && this.canvas.parentNode) {
                    this.canvas.remove();
                  }
                }, 300);
              };
              
              this.img.onerror = () => {};
              
              this.img.src = objectUrl;
              this.appendChild(this.img);
              
            } catch (error) {
            }
          }
        }
      );

      const getEnvVar = (name, defaultValue = "") => {
        return (window.ENV && window.ENV[name]) || defaultValue;
      };

      var app = Elm.Main.init({
        node: document.getElementById("myapp"),
        flags: {
          currentDateMillis: Date.now(),
          immichApiKey: getEnvVar("IMMICH_API_KEY", ""),
          immichApiUrl: getEnvVar("IMMICH_URL", "https://localhost"),
        },
      });

      if (!window.storageAPI) {
        window.storageAPI = {
          save: function(key, value) {
            try {
              localStorage.setItem(key, value);
            } catch (error) {
            }
          },
          load: function(key) {
            try {
              return localStorage.getItem(key);
            } catch (error) {
              return null;
            }
          },
          clear: function() {
            try {
              localStorage.removeItem('immichApiUrl');
              localStorage.removeItem('immichApiKey');
            } catch (error) {
            }
          }
        };
      }

      app.ports.openUrl.subscribe(function (url) {
        window.open(url, "_blank");
      });

      app.ports.saveToStorage.subscribe(function (data) {
        const [key, value] = data;
        if (window.storageAPI.save.constructor.name === 'AsyncFunction') {
          window.storageAPI.save(key, value).catch(function(error) {});
        } else {
          window.storageAPI.save(key, value);
        }
      });

      app.ports.loadFromStorage.subscribe(function (key) {
        if (window.storageAPI.load.constructor.name === 'AsyncFunction') {
          window.storageAPI.load(key).then(function(value) {
            app.ports.storageLoaded.send([key, value]);
          }).catch(function(error) {
            app.ports.storageLoaded.send([key, null]);
          });
        } else {
          const value = window.storageAPI.load(key);
          app.ports.storageLoaded.send([key, value]);
        }
      });

      app.ports.clearStorage.subscribe(function () {
        window.storageAPI.clear();
      });

      async function yankAssetToClipboard(assetId) {
        try {
          // Find the asset URL from the cache based on asset ID
          let assetBlobUrl = null;
          
          // Look for the asset in our cache
          for (const [url, blobUrl] of assetCache.entries()) {
            if (url.includes(assetId)) {
              assetBlobUrl = blobUrl;
              break;
            }
          }
          
          if (!assetBlobUrl) {
            return;
          }
          
          // Fetch the blob from the object URL
          const response = await fetch(assetBlobUrl);
          const originalBlob = await response.blob();
          
          // Only handle images - videos don't work with clipboard
          if (!originalBlob.type.startsWith('image/')) {
            return;
          }
          
          // Check if clipboard API is available
          if (!navigator.clipboard || !navigator.clipboard.write) {
            return;
          }
          
          // Try PNG blob approach (this works for chat apps)
          try {
            const pngBlob = new Blob([originalBlob], { type: 'image/png' });
            await navigator.clipboard.write([
              new ClipboardItem({
                'image/png': pngBlob
              })
            ]);
            return;
          } catch (error) {
            // Fallback: try the original blob type
            try {
              await navigator.clipboard.write([
                new ClipboardItem({
                  [originalBlob.type]: originalBlob
                })
              ]);
            } catch (fallbackError) {
              // Silent failure
            }
          }
          
        } catch (error) {
          // Silent failure
        }
      }

      app.ports.yankAssetToClipboard.subscribe(function (assetId) {
        yankAssetToClipboard(assetId);
      });
    </script>
  </body>
</html>
