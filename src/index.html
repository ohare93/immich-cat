<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Main</title>
    <script src="../dist/main.js"></script>
    <script src="../node_modules/thumbhash/thumbhash.js"></script>
    <style>
      .center {
        text-align: center;
        width: auto;
        max-height: 100vh;
        max-width: 100%;
        white-space: nowrap;
      }

      .center img {
        max-width: 100%; /* Restrict the image width to the width of its container */
        max-height: 100%; /* Restrict the image height to maintain aspect ratio */
        display: block; /* Ensure the image behaves as a block element */
        margin: 0 auto; /* Center the image horizontally within the container */
      }
    </style>
  </head>
  <body>
    <div id="myapp"></div>
    <script type="text/javascript">
      // Cache for storing blob URLs
      const assetCache = new Map();
      const preloadQueue = new Set();
      const maxCacheSize = 50; // Max number of cached assets

      function fetchWithAuthentication(url, authToken) {
        const headers = new Headers();
        headers.set("x-api-key", authToken);
        return fetch(url, { headers });
      }

      function cleanupOldCache() {
        if (assetCache.size > maxCacheSize) {
          const oldEntries = Array.from(assetCache.entries()).slice(
            0,
            assetCache.size - maxCacheSize,
          );
          oldEntries.forEach(([url, blobUrl]) => {
            URL.revokeObjectURL(blobUrl);
            assetCache.delete(url);
          });
        }
      }

      async function getProtectedAssetUrl(imageUrl, authToken) {
        // Check cache first
        if (assetCache.has(imageUrl)) {
          return assetCache.get(imageUrl);
        }

        // Prevent multiple simultaneous fetches of the same asset
        if (preloadQueue.has(imageUrl)) {
          // Wait for the ongoing fetch to complete
          while (preloadQueue.has(imageUrl) && !assetCache.has(imageUrl)) {
            await new Promise((resolve) => setTimeout(resolve, 50));
          }
          return assetCache.get(imageUrl);
        }

        preloadQueue.add(imageUrl);

        try {
          // Fetch the image.
          const response = await fetchWithAuthentication(imageUrl, authToken);

          // Create an object URL from the data.
          const blob = await response.blob();
          const objectUrl = URL.createObjectURL(blob);

          // Store in cache
          assetCache.set(imageUrl, objectUrl);
          cleanupOldCache();

          return objectUrl;
        } finally {
          preloadQueue.delete(imageUrl);
        }
      }

      // Preload function for adjacent images
      function preloadAsset(imageUrl, authToken) {
        if (!assetCache.has(imageUrl) && !preloadQueue.has(imageUrl)) {
          getProtectedAssetUrl(imageUrl, authToken).catch(console.error);
        }
      }

      // Shared base class for media elements
      class MediaElementBase extends HTMLElement {
        constructor(config) {
          super();
          this.config = config;
          this.assetBlob = null;
          this.currentVideo = null; // Track current video element for cleanup
        }

        connectedCallback() {
          // Initialize properties but don't start loading yet
          // We'll wait for attributes to be set via attributeChangedCallback
          this.assetUrl = this.getAttribute("asset-url");
          this.apiKey = this.getAttribute("api-key");
          this.preloadList = this.getAttribute("preload-urls");

          // Show initial loading state
          this.render();
        }

        async attributeChangedCallback(name, oldValue, newValue) {
          if (name === "api-key") {
            this.apiKey = newValue;
          } else if (name === "asset-url") {
            this.assetUrl = newValue;
            // Clear existing blob when URL changes so new asset can load
            this.assetBlob = null;
            // Stop and cleanup any existing video
            this.cleanupCurrentVideo();
          } else if (name === "preload-urls") {
            this.preloadList = newValue;
          }

          // Start loading when we have both asset URL and API key
          if (
            this.assetUrl &&
            this.apiKey &&
            this.apiKey !== "undefined" &&
            !this.assetBlob
          ) {
            this.render(); // Show loading state

            try {
              this.assetBlob = await getProtectedAssetUrl(
                this.assetUrl,
                this.apiKey,
              );

              // Preload adjacent assets using config
              if (this.preloadList) {
                const urls = this.preloadList.split(",");
                const urlsToPreload = this.config.preloadCount
                  ? urls.slice(0, this.config.preloadCount)
                  : urls;

                urlsToPreload.forEach((url) => {
                  if (url.trim()) {
                    if (this.config.preloadDelay) {
                      setTimeout(
                        () => preloadAsset(url.trim(), this.apiKey),
                        this.config.preloadDelay,
                      );
                    } else {
                      preloadAsset(url.trim(), this.apiKey);
                    }
                  }
                });
              }

              this.render(); // Show actual asset

              // Execute post-render callback if provided
              if (this.config.postRender) {
                this.config.postRender(this);
              }
            } catch (error) {
              console.error(`Error loading ${this.config.mediaType}:`, error);
              this.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #f66;">
                  Error loading ${this.config.mediaType}
                </div>
              `;
            }
          }
        }

        static get observedAttributes() {
          return ["asset-url", "api-key", "preload-urls"];
        }

        render() {
          if (this.assetBlob) {
            this.innerHTML = this.config.renderElement(this.assetBlob);
          } else {
            this.innerHTML = this.config.renderLoading();
          }
        }

        cleanupCurrentVideo() {
          if (this.currentVideo) {
            this.currentVideo.pause();
            this.currentVideo.currentTime = 0;
            this.currentVideo.src = "";
            this.currentVideo.load(); // Reset the video element
            this.currentVideo = null;
          }
        }

        disconnectedCallback() {
          // Clean up when element is removed from DOM
          this.cleanupCurrentVideo();
        }

        showVideoError(message) {
          this.innerHTML = `
            <div style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; background: #ffebee; border: 2px solid #f44336; border-radius: 8px; padding: 20px; margin: 10px;">
              <div style="color: #d32f2f; font-size: 18px; margin-bottom: 10px;">⚠️ Video Error</div>
              <div style="color: #666; text-align: center; font-size: 14px; max-width: 400px;">${message}</div>
              <div style="color: #999; text-align: center; font-size: 12px; margin-top: 10px;">
                This video may have compatibility issues with this platform.
              </div>
            </div>
          `;
        }

        showVideoWarning(message) {
          // Create a warning overlay on top of the video
          const warningDiv = document.createElement('div');
          warningDiv.style.cssText = `
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 152, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 200px;
            z-index: 1000;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
          `;
          warningDiv.textContent = `⚠️ ${message}`;
          
          // Position the parent element relatively if not already
          if (this.style.position !== 'relative') {
            this.style.position = 'relative';
          }
          
          this.appendChild(warningDiv);
          
          // Auto-hide warning after 8 seconds
          setTimeout(() => {
            if (warningDiv.parentNode) {
              warningDiv.remove();
            }
          }, 8000);
        }
      }

      customElements.define(
        "image-from-api",
        class extends MediaElementBase {
          constructor() {
            super({
              mediaType: "image",
              preloadCount: null, // Preload all
              preloadDelay: null, // Immediate
              renderElement: (blobUrl) =>
                `<img src="${blobUrl}" alt="Asset" />`,
              renderLoading: () => `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                  Loading...
                </div>
              `,
              postRender: null,
            });
          }
        },
      );

      customElements.define(
        "video-from-api",
        class extends MediaElementBase {
          constructor() {
            super({
              mediaType: "video",
              preloadCount: 2, // Only preload 2 adjacent videos
              preloadDelay: 1000, // Delay video preloading by 1 second
              renderElement: (blobUrl) =>
                `<video src="${blobUrl}" controls="controls" autoplay loop style="max-width: 100%; max-height: 100%;" />`,
              renderLoading: () => `
                <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
                  Loading video...
                </div>
              `,
              postRender: (element) => {
                // Clean up any previous video first
                element.cleanupCurrentVideo();
                
                // Use event-based approach instead of setTimeout for better QuteBrowser compatibility
                const video = element.querySelector("video");
                if (video) {
                  // Track this video for cleanup
                  element.currentVideo = video;
                  
                  video.addEventListener('loadeddata', () => {
                    // Only try manual play if autoplay didn't work
                    if (video.paused) {
                      video.play().catch(console.error);
                    }
                  });
                  
                  // Log errors but don't show user warnings
                  video.addEventListener('error', (e) => {
                    console.error('Video error:', e.target.error);
                  });
                }
              },
            });
          }
        },
      );

      // ThumbHash-to-Image Web Component
      customElements.define(
        "thumbhash-image",
        class extends HTMLElement {
          constructor() {
            super();
            this.thumbhashString = null;
            this.assetUrl = null;
            this.apiKey = null;
            this.canvas = null;
            this.img = null;
            this.hasLoadedFullImage = false;
          }

          connectedCallback() {
            this.style.display = "block";
            this.style.width = "100%";
            this.style.height = "100%";
            this.style.position = "relative";
            this.style.overflow = "hidden";
            
            this.thumbhashString = this.getAttribute("thumbhash");
            this.assetUrl = this.getAttribute("asset-url");
            this.apiKey = this.getAttribute("api-key");
            
            this.render();
          }

          attributeChangedCallback(name, oldValue, newValue) {
            if (name === "thumbhash") {
              this.thumbhashString = newValue;
            } else if (name === "asset-url") {
              this.assetUrl = newValue;
              this.hasLoadedFullImage = false;
            } else if (name === "api-key") {
              this.apiKey = newValue;
            }
            
            if (this.isConnected) {
              this.render();
            }
          }

          static get observedAttributes() {
            return ["thumbhash", "asset-url", "api-key"];
          }

          async render() {
            // Clear previous content
            this.innerHTML = "";
            
            // Show thumbhash placeholder first
            if (this.thumbhashString && window.thumbhash) {
              this.renderThumbhash();
            }
            
            // Then load full image
            if (this.assetUrl && this.apiKey && !this.hasLoadedFullImage) {
              this.loadFullImage();
            }
          }

          renderThumbhash() {
            try {
              // Decode base64 thumbhash string to Uint8Array
              const binaryString = atob(this.thumbhashString);
              const thumbhashArray = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                thumbhashArray[i] = binaryString.charCodeAt(i);
              }
              
              // Create canvas and render thumbhash
              this.canvas = document.createElement("canvas");
              this.canvas.style.width = "100%";
              this.canvas.style.height = "100%";
              this.canvas.style.objectFit = "cover";
              this.canvas.style.position = "absolute";
              this.canvas.style.top = "0";
              this.canvas.style.left = "0";
              this.canvas.style.filter = "blur(1px)"; // Slight blur for aesthetic
              
              // Use thumbhash library to decode
              const { w, h, rgba } = window.thumbhash.thumbHashToRGBA(thumbhashArray);
              this.canvas.width = w;
              this.canvas.height = h;
              
              const ctx = this.canvas.getContext("2d");
              const imageData = ctx.createImageData(w, h);
              imageData.data.set(rgba);
              ctx.putImageData(imageData, 0, 0);
              
              this.appendChild(this.canvas);
              
            } catch (error) {
              console.error("Error rendering thumbhash:", error);
              this.renderPlaceholder();
            }
          }

          renderPlaceholder() {
            const placeholder = document.createElement("div");
            placeholder.style.width = "100%";
            placeholder.style.height = "100%";
            placeholder.style.background = "#f0f0f0";
            placeholder.style.display = "flex";
            placeholder.style.alignItems = "center";
            placeholder.style.justifyContent = "center";
            placeholder.style.color = "#999";
            placeholder.style.fontSize = "12px";
            placeholder.textContent = "Loading...";
            this.appendChild(placeholder);
          }

          async loadFullImage() {
            if (!this.assetUrl || !this.apiKey) return;
            
            try {
              const objectUrl = await getProtectedAssetUrl(this.assetUrl, this.apiKey);
              
              this.img = document.createElement("img");
              this.img.style.width = "100%";
              this.img.style.height = "100%";
              this.img.style.objectFit = "cover";
              this.img.style.position = "absolute";
              this.img.style.top = "0";
              this.img.style.left = "0";
              this.img.style.opacity = "0";
              this.img.style.transition = "opacity 0.3s ease";
              
              this.img.onload = () => {
                this.img.style.opacity = "1";
                this.hasLoadedFullImage = true;
                
                // Remove thumbhash canvas after full image loads
                setTimeout(() => {
                  if (this.canvas && this.canvas.parentNode) {
                    this.canvas.remove();
                  }
                }, 300);
              };
              
              this.img.onerror = () => {
                console.error("Error loading full image");
              };
              
              this.img.src = objectUrl;
              this.appendChild(this.img);
              
            } catch (error) {
              console.error("Error loading full image:", error);
            }
          }
        }
      );

      // Get environment variables from the running process (secure runtime injection)
      const getEnvVar = (name, defaultValue = "") => {
        // In development, these will be injected by the dev server
        // In production, these will be passed via server-side rendering or build-time injection
        return (window.ENV && window.ENV[name]) || defaultValue;
      };

      var app = Elm.Main.init({
        node: document.getElementById("myapp"),
        flags: {
          currentDateMillis: Date.now(),
          immichApiKey: getEnvVar("IMMICH_API_KEY", ""),
          immichApiUrl: getEnvVar("IMMICH_URL", "https://localhost"),
        },
      });

      // Diagnostic logging
      console.log('ENV available:', !!window.ENV);
      console.log('storageAPI available:', !!window.storageAPI);
      console.log('Current location:', window.location.href);

      // Fallback storageAPI if not injected by dev server
      if (!window.storageAPI) {
        console.warn('storageAPI not found, creating fallback implementation');
        console.warn('This suggests you are loading the file directly instead of through the dev server');
        window.storageAPI = {
          save: function(key, value) {
            try {
              localStorage.setItem(key, value);
              console.log('Saved to localStorage (fallback):', key);
            } catch (error) {
              console.error('Failed to save to localStorage:', error);
            }
          },
          load: function(key) {
            try {
              return localStorage.getItem(key);
            } catch (error) {
              console.error('Failed to load from localStorage:', error);
              return null;
            }
          },
          clear: function() {
            try {
              localStorage.removeItem('immichApiUrl');
              localStorage.removeItem('immichApiKey');
              console.log('Cleared localStorage (fallback)');
            } catch (error) {
              console.error('Failed to clear localStorage:', error);
            }
          }
        };
      }

      // Port subscriptions
      app.ports.openUrl.subscribe(function (url) {
        window.open(url, "_blank");
      });

      // localStorage port connections
      app.ports.saveToStorage.subscribe(function (data) {
        const [key, value] = data;
        if (window.storageAPI.save.constructor.name === 'AsyncFunction') {
          // Handle async version (with encryption)
          window.storageAPI.save(key, value).catch(function(error) {
            console.error('Error saving to storage:', error);
          });
        } else {
          // Handle sync version (fallback)
          window.storageAPI.save(key, value);
        }
      });

      app.ports.loadFromStorage.subscribe(function (key) {
        if (window.storageAPI.load.constructor.name === 'AsyncFunction') {
          // Handle async version (with encryption)
          window.storageAPI.load(key).then(function(value) {
            app.ports.storageLoaded.send([key, value]);
          }).catch(function(error) {
            console.error('Error loading from storage:', error);
            app.ports.storageLoaded.send([key, null]);
          });
        } else {
          // Handle sync version (fallback)
          const value = window.storageAPI.load(key);
          app.ports.storageLoaded.send([key, value]);
        }
      });

      app.ports.clearStorage.subscribe(function () {
        window.storageAPI.clear();
      });
    </script>
  </body>
</html>
