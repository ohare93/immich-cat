<!doctype html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Main</title>
    <script src="../dist/main.js"></script>
    <style>
      .center {
        text-align: center;
        width: auto;
        max-height: 100vh;
        max-width: 100%;
        white-space: nowrap;
      }

      .center img {
        max-width: 100%; /* Restrict the image width to the width of its container */
        max-height: 100%; /* Restrict the image height to maintain aspect ratio */
        display: block; /* Ensure the image behaves as a block element */
        margin: 0 auto; /* Center the image horizontally within the container */
      }
    </style>
  </head>
  <body>
    <div id="myapp"></div>
    <script type="text/javascript">
      // Cache for storing blob URLs
      const assetCache = new Map();
      const preloadQueue = new Set();
      const maxCacheSize = 50; // Max number of cached assets

      function fetchWithAuthentication(url, authToken) {
        const headers = new Headers();
        headers.set("x-api-key", authToken);
        return fetch(url, { headers });
      }

      function cleanupOldCache() {
        if (assetCache.size > maxCacheSize) {
          const oldEntries = Array.from(assetCache.entries()).slice(
            0,
            assetCache.size - maxCacheSize,
          );
          oldEntries.forEach(([url, blobUrl]) => {
            URL.revokeObjectURL(blobUrl);
            assetCache.delete(url);
          });
        }
      }

      async function getProtectedAssetUrl(imageUrl, authToken) {
        // Check cache first
        if (assetCache.has(imageUrl)) {
          return assetCache.get(imageUrl);
        }

        // Prevent multiple simultaneous fetches of the same asset
        if (preloadQueue.has(imageUrl)) {
          // Wait for the ongoing fetch to complete
          while (preloadQueue.has(imageUrl) && !assetCache.has(imageUrl)) {
            await new Promise((resolve) => setTimeout(resolve, 50));
          }
          return assetCache.get(imageUrl);
        }

        preloadQueue.add(imageUrl);

        try {
          // Fetch the image.
          const response = await fetchWithAuthentication(imageUrl, authToken);

          // Create an object URL from the data.
          const blob = await response.blob();
          const objectUrl = URL.createObjectURL(blob);

          // Store in cache
          assetCache.set(imageUrl, objectUrl);
          cleanupOldCache();

          return objectUrl;
        } finally {
          preloadQueue.delete(imageUrl);
        }
      }

      // Preload function for adjacent images
      function preloadAsset(imageUrl, authToken) {
        if (!assetCache.has(imageUrl) && !preloadQueue.has(imageUrl)) {
          getProtectedAssetUrl(imageUrl, authToken).catch(console.error);
        }
      }

      customElements.define(
        "image-from-api",
        class extends HTMLElement {
          constructor() {
            super();
            //this.attachShadow({mode: 'open'});
          }
          connectedCallback() {
            // Initialize properties but don't start loading yet
            // We'll wait for attributes to be set via attributeChangedCallback
            this.assetUrl = this.getAttribute("asset-url");
            this.apiKey = this.getAttribute("api-key");
            this.preloadList = this.getAttribute("preload-urls");
            
            // Show initial loading state
            this.render();
          }
          async attributeChangedCallback(name, oldValue, newValue) {
            if (name === 'api-key') {
              this.apiKey = newValue;
            } else if (name === 'asset-url') {
              this.assetUrl = newValue;
              // Clear existing blob when URL changes so new asset can load
              this.assetBlob = null;
            } else if (name === 'preload-urls') {
              this.preloadList = newValue;
            }
            
            // Start loading when we have both asset URL and API key
            if (this.assetUrl && this.apiKey && this.apiKey !== 'undefined' && !this.assetBlob) {
              this.render(); // Show loading state
              
              try {
                this.assetBlob = await getProtectedAssetUrl(this.assetUrl, this.apiKey);
                
                // Preload adjacent images
                if (this.preloadList) {
                  const urls = this.preloadList.split(",");
                  urls.forEach((url) => {
                    if (url.trim()) {
                      preloadAsset(url.trim(), this.apiKey);
                    }
                  });
                }
                
                this.render(); // Show actual image
              } catch (error) {
                console.error('Error loading image:', error);
                this.innerHTML = `
                  <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #f66;">
                    Error loading image
                  </div>
                `;
              }
            }
          }
          static get observedAttributes() {
            return ["asset-url", "api-key", "preload-urls"];
          }

          render() {
            if (this.assetBlob) {
              this.innerHTML = `
			<img src="${this.assetBlob}" alt="Asset" />
		    `;
            } else {
              this.innerHTML = `
			<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
			    Loading...
			</div>
		    `;
            }
          }
        },
      );

      customElements.define(
        "video-from-api",
        class extends HTMLElement {
          constructor() {
            super();
            //this.attachShadow({mode: 'open'});
          }
          async connectedCallback() {
            this.assetUrl = this.getAttribute("asset-url");
            this.apiKey = this.getAttribute("api-key");
            this.preloadList = this.getAttribute("preload-urls");

            // Show loading state first
            this.render();

            this.assetBlob = await getProtectedAssetUrl(
              this.assetUrl,
              this.apiKey,
            );

            // Preload adjacent videos (smaller priority than images)
            if (this.preloadList) {
              const urls = this.preloadList.split(",");
              urls.slice(0, 2).forEach((url) => {
                // Only preload 2 adjacent videos
                if (url.trim()) {
                  setTimeout(() => preloadAsset(url.trim(), this.apiKey), 1000); // Delay video preloading
                }
              });
            }

            // Now render with the actual asset
            this.render();
          }
          async attributeChangedCallback() {
            const newAssetUrl = this.getAttribute("asset-url");
            if (this.assetUrl !== newAssetUrl) {
              this.assetUrl = newAssetUrl;
              this.assetBlob = await getProtectedAssetUrl(
                this.assetUrl,
                this.apiKey,
              );
              this.render();
            }
            this.render();
          }
          static get observedAttributes() {
            return ["asset-url", "api-key", "preload-urls"];
          }

          render() {
            if (this.assetBlob) {
              this.innerHTML = `
		  <video src="${this.assetBlob}" controls="controls" autoplay loop style="max-width: 100%; max-height: 100%;" />
		`;
              // Force autoplay after render
              setTimeout(() => {
                const video = this.querySelector('video');
                if (video) {
                  video.play().catch(console.error);
                }
              }, 100);
            } else {
              this.innerHTML = `
		  <div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #666;">
		    Loading video...
		  </div>
		`;
            }
          }
        },
      );

      // Get environment variables from the running process (secure runtime injection)
      const getEnvVar = (name, defaultValue = "") => {
        // In development, these will be injected by the dev server
        // In production, these will be passed via server-side rendering or build-time injection
        return (window.ENV && window.ENV[name]) || defaultValue;
      };

      var app = Elm.Main.init({
        node: document.getElementById("myapp"),
        flags: {
          test: Date.now(),
          immichApiKey: getEnvVar("IMMICH_API_KEY", ""),
          immichApiUrl: getEnvVar("IMMICH_URL", "https://localhost/api"),
        },
      });
    </script>
  </body>
</html>
